// Dataset-level constraints example
// Validates aggregate constraints across entire collections

schema Invoice {
  id: int in 1..10000,
  customer: string,
  total: int in 100..500,
  amount_paid: int in 0..0,
  status: "unpaid" | "draft",
}

schema Payment {
  id: int in 1..10000,
  invoice: any of invoices,
  amount: int in 50..200,

  assume amount <= invoice.total
} then {
  invoice.amount_paid += amount,
  // Use ternary to set status based on whether fully paid
  invoice.status = invoice.amount_paid >= invoice.total ? "paid" : "partially-paid"
}

dataset FinancialData {
  invoices: 20 * Invoice,
  payments: 30 * Payment,

  validate {
    // Total invoices should be in a reasonable range
    sum(invoices.total) >= 3000,
    sum(invoices.total) <= 8000,

    // Payments can't exceed invoices
    sum(payments.amount) <= sum(invoices.total),

    // Can't have more payments than invoices
    count(payments) <= count(invoices) * 3
  }
}
