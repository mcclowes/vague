// Dataset-level constraints example
// Validates aggregate constraints across entire collections

schema Invoice {
  id: int in 1..10000,
  customer: string,
  total: int in 200..1000,
  amount_paid: int in 0..0,        // Starts at 0, updated by payments
  status: "unpaid" | "draft",
  notes: string?                   // Nullable field - sometimes null
}

schema Payment {
  id: int in 1..10000, 
  invoice: any of invoices,
  // Amount is either a partial payment (10-500) or the full invoice total
  // Unweighted: equal chance of either option
  // amount: int in 10..500 | invoice.total,
  // Weighted: 30% partial payments, 70% full payments
  amount: 0.3: int in 10..500 | 0.7: invoice.total,

  // Payment cannot exceed remaining balance
  assume amount <= invoice.total - invoice.amount_paid
} then {
  invoice.amount_paid += amount,
  // Use ternary to set status based on whether fully paid
  invoice.status = invoice.amount_paid >= invoice.total ? "paid" : "partially-paid"
}

dataset FinancialData {
  invoices: 20 * Invoice,
  payments: 40 * Payment,

  validate {
    // Total invoices should be in a reasonable range
    // 20 invoices * 200-1000 each = 4000-20000 range
    sum(invoices.total) >= 5000,
    sum(invoices.total) <= 18000,

    // Payments can't exceed invoices
    sum(payments.amount) <= sum(invoices.total),

    // Can't have more payments than invoices * 3
    count(payments) <= count(invoices) * 3,

    // No invoice should be overpaid (amount_paid must not exceed total)
    all(invoices, .amount_paid <= .total)
  }
}
