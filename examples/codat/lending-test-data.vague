// Codat Lending API - Test Data Generation
// Based on https://github.com/codatio/oas
//
// This generates realistic test data for an SMB lending scenario:
// - Companies with connections to accounting platforms
// - Customers and suppliers
// - Invoices (accounts receivable) with line items
// - Payments against invoices that update invoice status
//
// Demonstrates:
// - OpenAPI schema imports (`from codat.Schema`)
// - `then` blocks for payment side effects
// - Dataset-level validation with predicates
// - Ternary expressions for conditional values
// - Nullable fields with `?` syntax

import codat from "Codat-Lending.json"

// --- Base Schemas (inheriting from OpenAPI) ---

schema Customer from codat.AccountingCustomer {
  id: uuid(),
  customerName: companyName(),
  contactName: fullName(),
  emailAddress: email(),
  phone: phone(),
  status: 0.85: "Active" | 0.15: "Archived",
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD"
}

schema InvoiceLineItem {
  description: faker.commerce.productName(),
  quantity: int in 1..100,
  unitAmount: decimal in 10..5000,
  discountAmount: decimal in 0..100,
  taxAmount: = unitAmount * 0.2,
  totalAmount: = unitAmount * quantity
}

schema Invoice from codat.AccountingInvoice {
  id: uuid(),
  invoiceNumber: faker.string.alphanumeric(8),
  customerRef: any of customers,
  issueDate: int in 1..28,
  dueDate: int in 1..90,
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",

  lineItems: 1..8 * InvoiceLineItem,

  // Computed totals
  subTotal: = sum(lineItems.unitAmount),
  totalTaxAmount: = sum(lineItems.taxAmount),
  totalAmount: = sum(lineItems.totalAmount),

  // Start unpaid - payments will update these via `then` blocks
  amountDue: = totalAmount,
  status: "Submitted",

  // Constraints
  assume dueDate >= issueDate
}

schema PaymentLineLink {
  type: "Invoice" | "CreditNote" | "PaymentOnAccount",
  id: uuid(),
  amount: int in 0..10000
}

schema PaymentLine {
  amount: int in 0..10000,
  links: 1..3 * PaymentLineLink
}

// Payment mutates the referenced invoice via `then` block
schema Payment from codat.AccountingPayment {
  id: uuid(),
  invoice: any of invoices where .status != "Paid" and .status != "Void",
  amount: int in 100..5000,
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  date: int in 1..28,
  note: sentence()?,
  reference: faker.string.alphanumeric(10)?,

  // Payment cannot exceed remaining balance
  assume amount <= invoice.amountDue
} then {
  invoice.amountDue -= amount,
  // Ternary: set status based on remaining balance
  invoice.status = invoice.amountDue <= 0 ? "Paid" : "PartiallyPaid"
}

schema Account from codat.AccountingAccount {
  id: uuid(),
  nominalCode: faker.string.alphanumeric(6),
  name: faker.finance.accountNumber(),
  description: sentence()?,
  currency: "GBP" | "USD" | "EUR",
  currentBalance: decimal in 0..500000,
  type: 0.3: "Asset" | 0.2: "Liability" | 0.15: "Equity" | 0.2: "Income" | 0.15: "Expense",
  status: 0.9: "Active" | 0.1: "Archived",
  isBankAccount: 0.2: true | 0.8: false
}

schema Supplier from codat.AccountingSupplier {
  id: uuid(),
  supplierName: companyName(),
  contactName: fullName()?,
  emailAddress: email()?,
  phone: phone()?,
  status: 0.9: "Active" | 0.1: "Archived",
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD"
}

schema BillLineItem {
  description: faker.commerce.productName(),
  quantity: int in 1..50,
  unitAmount: decimal in 10..2000,
  taxAmount: = unitAmount * 0.2,
  totalAmount: = unitAmount * quantity
}

schema Bill from codat.AccountingBill {
  id: uuid(),
  reference: faker.string.alphanumeric(8)?,
  supplierRef: any of suppliers,
  issueDate: int in 1..28,
  dueDate: int in 1..60,
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",

  lineItems: 1..5 * BillLineItem,

  subTotal: = sum(lineItems.unitAmount),
  totalTaxAmount: = sum(lineItems.taxAmount),
  totalAmount: = sum(lineItems.totalAmount),

  // Dynamic status based on amounts
  amountDue: = totalAmount,
  status: "Open",

  assume dueDate >= issueDate
}

// Bill payment - similar pattern to invoice payments
schema BillPayment {
  id: uuid(),
  bill: any of bills where .status != "Paid",
  amount: int in 100..3000,
  date: int in 1..28,

  assume amount <= bill.amountDue
} then {
  bill.amountDue -= amount,
  bill.status = bill.amountDue <= 0 ? "Paid" : "PartiallyPaid"
}

schema Connection {
  id: uuid(),
  integrationId: uuid(),
  platformName: "Xero" | "QuickBooks" | "Sage" | "FreshBooks" | "Wave",
  status: 0.85: "Linked" | 0.15: "Unlinked",
  sourceType: 0.7: "Accounting" | 0.2: "Banking" | 0.1: "Commerce"
}

schema Company {
  id: uuid(),
  name: companyName(),
  description: faker.company.catchPhrase()?,
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  // Dynamic cardinality: larger companies have more connections
  dataConnections: 1..3 * Connection
}

// --- Dataset Definition ---

dataset LendingTestData {
  // Companies applying for lending
  companies: 20 * Company,

  // Chart of accounts
  accounts: 50 * Account,

  // Customers (debtors)
  customers: 100 * Customer,

  // Suppliers (creditors)
  suppliers: 50 * Supplier,

  // Accounts receivable
  invoices: 500 * Invoice,

  // Payments received (these mutate invoices via `then` blocks)
  payments: 400 * Payment,

  // Accounts payable
  bills: 200 * Bill,

  // Bill payments (these mutate bills via `then` blocks)
  billPayments: 150 * BillPayment,

  // Dataset-level validation
  validate {
    // Total AR should be substantial for lending assessment
    sum(invoices.totalAmount) >= 100000,

    // Total AP shouldn't exceed AR (healthy business)
    sum(bills.totalAmount) <= sum(invoices.totalAmount) * 1.5,

    // Payments shouldn't exceed invoice totals
    sum(payments.amount) <= sum(invoices.totalAmount),

    // Some invoices should be paid (shows collection ability)
    some(invoices, .status == "Paid"),

    // No invoice should be overpaid
    all(invoices, .amountDue >= 0),

    // No bill should be overpaid
    all(bills, .amountDue >= 0)
  }
}
