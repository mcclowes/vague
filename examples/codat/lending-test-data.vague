import codat from "Codat-Lending.json"

// Customers (debtors)
schema Customer from codat.AccountingCustomer {
  id: unique uuid(),
  customerName: companyName(),
  contactName: fullName(),
  emailAddress: email(),
  phone: phone(),
  status: 0.85: "Active" | "Archived",
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",

  // Conditional field - only business customers have registration numbers
  registrationNumber: string when status == "Active"
}

// Invoice line items with computed tax
schema InvoiceLineItem {
  description: faker.commerce.productName(),
  quantity: int in 1..100,
  unitAmount: decimal(2) in 10..5000,
  discountAmount: decimal(2) in 0..100,
  taxAmount: round(unitAmount * 0.2, 2),
  totalAmount: round((unitAmount - discountAmount) * quantity, 2)
}

// Invoices (accounts receivable)
schema Invoice from codat.AccountingInvoice {
  id: unique uuid(),
  invoiceNumber: sequence("INV-", 1001),
  customerRef: any of customers where .status == "Active",
  issueDate: date in 2023..2024,
  // Date arithmetic: due date is 30 days after issue
  dueDate: issueDate + date.days(30),
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  lineItems: 1..8 of InvoiceLineItem,
  subTotal: round(sum(lineItems.unitAmount), 2),
  totalTaxAmount: round(sum(lineItems.taxAmount), 2),
  totalAmount: round(sum(lineItems.totalAmount), 2),
  amountDue: totalAmount,
  status: "Submitted",

  // Constraint: due date must be after issue date
  assume dueDate >= issueDate
}

// Payments against invoices
schema Payment from codat.AccountingPayment {
  id: unique uuid(),
  invoice: any of invoices where not (.status == "Paid" or .status == "Void"),
  amount: decimal(2) in 100..5000,
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  paymentDate: date in 2024..2024,
  note: sentence()?,
  reference: faker.string.alphanumeric(10)?,

  // Conditional fields based on payment method
  paymentMethod: 0.6: "BankTransfer" | 0.3: "Card" | 0.1: "Cash",
  cardLast4: string when paymentMethod == "Card",
  bankReference: string when paymentMethod == "BankTransfer",

  assume amount <= invoice.amountDue
} then {
  invoice.amountDue = invoice.amountDue - amount,
  invoice.status = invoice.amountDue <= 0 ? "Paid" : "PartiallyPaid"
}

// Chart of accounts
schema Account from codat.AccountingAccount {
  id: unique uuid(),
  nominalCode: faker.string.alphanumeric(6),
  name: faker.finance.accountNumber(),
  description: sentence()?,
  currency: "GBP" | "USD" | "EUR",
  currentBalance: decimal(2) in 0..500000,
  type: 0.3: "Asset" | 0.2: "Liability" | 0.15: "Equity" | 0.2: "Income" | 0.15: "Expense",
  status: 0.9: "Active" | "Archived",
  isBankAccount: 0.2: true | 0.8: false,

  // Bank-specific fields only appear for bank accounts
  bankName: string when isBankAccount == true,
  accountNumber: string when isBankAccount == true,
  sortCode: string when isBankAccount == true
}

// Suppliers (creditors)
schema Supplier from codat.AccountingSupplier {
  id: unique uuid(),
  supplierName: companyName(),
  contactName: fullName()?,
  emailAddress: email()?,
  phone: phone()?,
  status: 0.9: "Active" | "Archived",
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",

  // Credit terms only for active suppliers
  creditDays: int in 14..90 when status == "Active",
  creditLimit: decimal(2) in 1000..100000 when status == "Active"
}

// Bill line items
schema BillLineItem {
  description: faker.commerce.productName(),
  quantity: int in 1..50,
  unitAmount: decimal(2) in 10..2000,
  taxAmount: round(unitAmount * 0.2, 2),
  totalAmount: round(unitAmount * quantity, 2)
}

// Bills (accounts payable)
schema Bill from codat.AccountingBill {
  id: unique uuid(),
  reference: sequence("BILL-", 1001),
  supplierRef: any of suppliers where .status == "Active",
  issueDate: date in 2023..2024,
  // Date arithmetic: due date based on supplier credit terms (default 30 days)
  dueDate: issueDate + date.days(30),
  currency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  lineItems: 1..5 of BillLineItem,
  subTotal: round(sum(lineItems.unitAmount), 2),
  totalTaxAmount: round(sum(lineItems.taxAmount), 2),
  totalAmount: round(sum(lineItems.totalAmount), 2),
  amountDue: totalAmount,
  status: "Open",

  assume dueDate >= issueDate
}

// Payments against bills
schema BillPayment {
  bill: any of bills where not .status == "Paid",
  amount: decimal(2) in 100..3000,
  paymentDate: date in 2024..2024,
  paymentMethod: 0.7: "BankTransfer" | 0.2: "DirectDebit" | 0.1: "Cheque",

  // Payment method specific fields
  bankReference: string when paymentMethod == "BankTransfer",
  directDebitId: string when paymentMethod == "DirectDebit",
  chequeNumber: string when paymentMethod == "Cheque",

  assume amount <= bill.amountDue
} then {
  bill.amountDue = bill.amountDue - amount,
  bill.status = bill.amountDue <= 0 ? "Paid" : "PartiallyPaid"
}

// Platform connections
schema Connection {
  integrationId: uuid(),
  platformName: "Xero" | "QuickBooks" | "Sage" | "FreshBooks" | "Wave",
  status: 0.85: "Linked" | "Unlinked",
  sourceType: 0.7: "Accounting" | 0.2: "Banking" | 0.1: "Commerce",

  // Connection-specific fields
  lastSyncDate: date in 2024..2024 when status == "Linked",
  errorMessage: string when status == "Unlinked"
}

// Companies with data connections - using private fields for metrics
schema Company {
  name: companyName(),
  description: faker.company.catchPhrase()?,
  defaultCurrency: 0.6: "GBP" | 0.25: "USD" | 0.1: "EUR" | 0.05: "AUD",
  dataConnections: 1..3 of Connection,

  // Private field for internal scoring (not output)
  _connectionScore: private int in 0..100,
  riskRating: _connectionScore >= 80 ? "Low" : _connectionScore >= 50 ? "Medium" : "High"
}

// Aged receivables summary with private intermediate calculations
schema AgedReceivablesSummary {
  // Private fields for intermediate calculations
  _current: private decimal(2) in 0..50000,
  _thirtyDays: private decimal(2) in 0..30000,
  _sixtyDays: private decimal(2) in 0..20000,
  _ninetyPlus: private decimal(2) in 0..10000,

  // Public computed fields
  currentAmount: _current,
  thirtyDaysAmount: _thirtyDays,
  sixtyDaysAmount: _sixtyDays,
  ninetyPlusDaysAmount: _ninetyPlus,
  totalOutstanding: round(_current + _thirtyDays + _sixtyDays + _ninetyPlus, 2),

  // Health indicator based on aging
  healthScore: _ninetyPlus / (_current + _thirtyDays + _sixtyDays + _ninetyPlus + 0.01) < 0.1 ? "Healthy" : "AtRisk"
}

dataset LendingTestData {
  companies: 20 of Company,
  accounts: 50 of Account,
  customers: 100 of Customer,
  suppliers: 50 of Supplier,
  invoices: 500 of Invoice,
  payments: 400 of Payment,
  bills: 200 of Bill,
  billPayments: 150 of BillPayment,
  agedReceivables: 20 of AgedReceivablesSummary,

  validate {
    sum(invoices.totalAmount) >= 100000,
    sum(bills.totalAmount) <= sum(invoices.totalAmount) * 1.5,
    sum(payments.amount) <= sum(invoices.totalAmount),
    some(invoices, .status == "Paid"),
    all(invoices, .amountDue >= 0),
    all(bills, .amountDue >= 0),
    // New validation: ensure some companies are low risk
    some(companies, .riskRating == "Low")
  }
}
